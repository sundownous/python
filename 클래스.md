파이썬은 객체지향 언어이고 객체를 우선해서 프로그래밍 한다는것
그리고 클래스를 기반으로 객체를 만들고 그러한 객체를 우선해서 프로그래밍을 해야한다

먼저 프로그래밍을 할때 어느 데이터를 통하여 개발을 할건지 생각을 해야한다

학생성적 관리 프로그램을 만드려면 무엇이 필요할까 뭐 이름 성적 뭐 그런 데이터들

만들어볼게유
클래스1.py

딕셔너리로 학생을 표현하고 그걸 리스트로 묶었다
이처럼 여러가지 속성을 가질 수 있는걸 객체라거 한다
근데 귀찮잖아 그러니 딕셔너리를 만드는 함수로 표현하자
클래스2.py

그런데 어차피 처리는 학생을 대상으로만 이루어지니 학생을 매개변수로 받는 코드로하면 객체와 처리를 분리가 가능하지 않을까
클래스3.py
근데 이런구조가 너무 자주 사용되서 이걸 클래스 기능으로 만듬

클래스 선언
class 클래스 이름:
    클래스 내용
이렇게 선언하면 되는데 단어의 앞글자를 대문자로 적어주는 센스가 필요하데 카멀케이스

이렇게 만들어진 클래스는 이름과 같은 함수 생성자를 사용하여 객체를 만든다
이전 코드의 creat_std같은거
인스턴스 이름(변수이름)=클래스 이름() 생성자 함수라고 부른다

class  Student:
    pass
    
student=Student()


생성자 
클래스이름과 같은 함수를 생성자라고 한다
클래스 내부에 __init__라는 함수를 만들면 객체를 생성할때 처리할 내용을 작성 할 수 있다
class 클래스 이름:
    def __init__(self, 추가적인매개변수):
        pass
    클래스 내부의 함수는 첫 매개변수로 무조건 self를 써야한다 self가 자기자신을 나타내는 딕셔너리라 생각하면 편하다
    속성과 기능에 접근할때 self.<식뱔자>로 접근한다
    그럼 creat_str을 클래스로 구현하면

class Student:
    def __init__(self,name,korean,...sicence):
    self.name=name
    self.korean=korean
    ...
    self.science=science

student=Student("홍길동",22,3,44,55)

접근할때는
student[0].name

메소드
클래스가 가지고 있는 함수다
클래스 내부 매소드를 만들때는 다음과 같이 사용한다
class 클래스 이름:
    def 매소드 이름(self, 추가적인매개변수):
        pass


클래스4.py

클래스는 어떤 클래스의 속성과 기능을 물려받아 새로운 클래스를 만드는 상속을 받을 수 있다
어떤 클래스의 인스턴스인지 확인하기
isinstance(인스턴스, 클래스)
이때 해당 인스턴스가 해당 클래스로 만들어졌으면 Ture를 반환한다
단순 인스턴스 식별은 type(인스턴스)==클래스
로 식별이 가능하다

인스턴스는 인스턴스들을 구분하며 속성과 기능을 사용할때 사용이 가능하다
클래스5 왜 elif를 쓴지 모르겠지만 아마 이게 구별하는거라서 그런건가 Student나 Teacher 말고 다른 클래스로 만든 인스턴스가 있을 수 있으니 elif로 쓴건가 else도 작동은 잘하네 

특수 메소드
파이썬이 기본으로 제공하는 특수 매소드 모두 이름 양옆애 __가 붙어있다
특수한 상황에 자동으로 호출된다
__str__함수 객체를 문자열로 만들 수 있다

클래스 변수는 그냥 클래스가 가ㅣㅈ고 있는 변수다
다를거 없다

클래스 함수도 그냥 클래스가 가진 함수다 근데 생성할때 데코레이터를 쓴다 
class 클래스 이름:
    @classmethod
    def 클래스함수(cls, 매개변수):
        pass

 이때 cls부분은 원하는 이름을 써도 되지만 cls쓰는게 근본이다
 클래스 함수의 첫번째 매개변수에는 클레스 자체가 들어온다 일반적으로 cls라고 적는다
 사용법은

 클래스이름.함수이름(매개변수)
 클래스7


 가비지 컬렉터 
 프로그램 내부에서 뭔가를 생성한다는것은 메로리 위에 올린다는것이다
 메모리가 부족해지면 컴퓨터는 하드디스크를 메모리처럼 쓴ㄴ데 이러한 동작을 스왑이라 한다
 이걸 방지하기 위해 파이썬은 가비지 컬랙터로 필요없는 데이터를 메모리에서 제거한다

 더 사용할 가능성이 없는 데이터는 변수에 저장하지 않는 데이터들이 있다 
 그래서 생성자와 소멸자로 변수에 저장했을때와 저장안했을때를 비교해보면
 변수에 저장했을때는 a생성b생성c생성a파괴b파과c파괴 지만
 변수에 저장을 안하면 즉시 파괴되서 a생성 a파괴 이런식으로 한다

프라이빗변수 
클래스 내부의 변수를 외부에서 사용 못하게 하는것
__변수이름 형태로 선언한다


이 변수에 접근하는것은 게터와 세터롤 접근한다
def 함수이름(self):
    return self.__변수이름
def 함수이름(self,매개변수):
    self.__변수이름=매개변수

여기 조건문을 넣어서 맞는 매개변수만 대입을 할 수 있더

데코레이터로도 가능핟
@property
def 함수이름(self):
    return self.__변수이름
@게터함수 이름.setter
 def 함수이름(self,매개변수):
    self.__변수이름=매개변

상속
클래스 기반 객체 지향 언어는 상속을 지원한다

부모클래스의 기능을 자식클래스도 사용이 가능하다

class Parent:
    def __init__(self):

        self.value="테스트"
        print("부모클래스의 생성자 호출")

    def test(self):
        print("부모의 test")
class Child(Parent):
    def __init__(self):
        supper().__init__()#부모의 생성자를 호출
        print("자식클래스")

child=Child()
child.test()
print(child.value)

이러면 자식클래스의 인스턴스를 생성하고 부모 메소들를 호출가능
오버라이드는 부모의 함수를 재정의 하는것이다

자식클래스에 새로움 함수를 만들기도 가능하다